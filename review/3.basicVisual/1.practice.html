<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>颜色表示-webgl-小试牛刀</title>
    <style>
        canvas{
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <canvas width="512" height="512"></canvas>

    <script type="module">
        import { Vector2D } from "/review/common/Vector2D.js";
        // 导入进行三角剖分的库
        import { earcut } from '/common/lib/earcut.js';

        /**
         * webgl原生五步用法
         * 1.创建webgl上下文
         * 2.创建webgl程序
         * 3.将数据存入缓冲区
         * 4.将数据读取到gpu
         * 5.gpu执行webgl程序
        */
        // 1.
        const canvas = document.querySelector("canvas");
        const gl = canvas.getContext("webgl");

        // 2.
        const vertex = `
            attribute vec2 position;
            attribute vec2 uv;

            varying vec2 vUv;

            void main(){
                gl_PointSize = 1.0;
                vUv = uv;
                gl_Position = vec4(position,1.0, 1.0);
            }
        `
        const fragment = `
            precision mediump float;

            varying vec2 vUv;

            void main(){
                float d = distance(vUv, vec2(0.5));
                d = step(0.2, d);
                gl_FragColor = vec4(vec3(d), 1.0);
            }
        `
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader,vertex);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader,fragment);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program,vertexShader);
        gl.attachShader(program,fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // 3.
        // 不规则多边形的顶点数组
        const vertices = [
            [-1, -1],
            [-1, 1],
            [1, 1],
            [1, -1],
        ];
        const uvs = [
            [0, 0],
            [0, 1],
            [1, 0],
            [1, 1],
        ];
        const earcutVertices = earcut(vertices.flat(), null, 2);
        
        const points = new Float32Array(vertices.flat());
        const uvspoints = new Float32Array(uvs.flat());
        const cells = new Uint16Array(earcutVertices);
        
        const pointBufferId = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pointBufferId);
        gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);

        // 4.从刚刚当前设置的缓冲区对象获取数据，设置顶点着色器
        const vPosition = gl.getAttribLocation(program, "position");
        gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(vPosition);

        // 设置纹理坐标的缓存数据
        const uvsBufferId = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, uvsBufferId);
        gl.bufferData(gl.ARRAY_BUFFER, uvspoints, gl.STATIC_DRAW);

        const vUv = gl.getAttribLocation(program, "uv");
        gl.vertexAttribPointer(vUv, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(vUv);

        // 设置三角剖分的缓存数据
        const cellBufferId = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,cellBufferId);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,cells, gl.STATIC_DRAW);

        // 5.
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawElements(gl.TRIANGLES, cells.length, gl.UNSIGNED_SHORT, 0);

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.模拟光照让3D场景更逼真-Phong反射模型</title>
    <style>
        canvas{
            border:1px solid #aaa;
            margin: 0 auto;
            display: block;
        }
    </style>
</head>
<body>
    <canvas width="512" height="512"></canvas>

    <script type="module">
        import { Renderer, Camera, Transform, Program, Color, Mesh, Texture, Orbit, Sphere, Box, Cylinder, Torus } from '/common/lib/ogl/index.mjs';
        import * as dat from '/common/lib/dat.gui.js';

        // 反射模型
        class Phong{
            constructor(ambientLight = [0.5, 0.5, 0.5]){
                // 定义环境光初始强度
                this.ambientLight = ambientLight;
                // 分别定义平行光、点光源、聚光灯的模型集合，主要作用是添加和删除光源
                this.directionalLights = new Set();
                this.pointLights = new Set();
                this.spotLights = new Set();
            }
            // 添加光源
            addLight(light){
                // position点光源、direction平行光、color光照强度、decay衰减系数、angle角度（聚光灯效果）
                const {position, direction, color, decay, angle} = light;
                // 如果没有输入光类型，抛出异常
                if(!position && !direction) throw new TypeError('invalid light');
                light.color = color || [1.0, 1.0, 1.0];
                // 如果没有添加点光源，直接把平行光加入集合中
                if(!position) this.directionalLights.add(light);
                // 如果是点光源，进行处理（点光源存在光的衰减）
                else{
                    // 衰减系数
                    light.decay = decay || [0, 0, 1];
                    // 判断点光源还是聚光灯
                    if(!angle){
                        this.pointLights.add(light);
                    }else{
                        this.spotLights.add(light);
                    }
                }
            }
            // 删除光源
            removeLight(light){
                if(this.directionalLights.has(light)) this.directionalLights.delete(light);
                else if(this.pointLights.has(light)) this.pointLights.delete(light);
                else if(this.spotLights.has(light)) this.spotLights.delete(light);
            }

            // 把光源属性通过uniforms访问器属性转换成着色器uniform变量
            get uniforms(){
                const MAX_LIGHT_COUNT = 16; // 最多每种光源设置16个
                this._lightData = this._lightData || {};
                const lightData = this._lightData;

                // 平行光的方向、光的强度
                lightData.directionalLightDirection = lightData.directionalLightDirection || { value: new Float32Array(MAX_LIGHT_COUNT * 3) };
                lightData.directionalLightColor = lightData.directionalLightColor || { value: new Float32Array(MAX_LIGHT_COUNT * 3) };

                // 点光源的位置、光强度、衰减系数
                lightData.pointLightPosition = lightData.pointLightPosition || { value: new Float32Array(MAX_LIGHT_COUNT * 3) };    
                lightData.pointLightColor = lightData.pointLightColor || { value: new Float32Array(MAX_LIGHT_COUNT * 3) };    
                lightData.pointLightDecay = lightData.pointLightDecay || { value: new Float32Array(MAX_LIGHT_COUNT * 3) };

                // 聚光灯的方向、位置、光强度、衰减系数、角度
                lightData.spotLightDirection = lightData.spotLightDirection || { value: new Float32Array(MAX_LIGHT_COUNT * 3) }; 
                lightData.spotLightPosition = lightData.spotLightPosition || { value: new Float32Array(MAX_LIGHT_COUNT * 3) }; 
                lightData.spotLightColor = lightData.spotLightColor || { value: new Float32Array(MAX_LIGHT_COUNT * 3) }; 
                lightData.spotLightDecay = lightData.spotLightDecay || { value: new Float32Array(MAX_LIGHT_COUNT * 3) }; 
                lightData.spotLightAngle = lightData.spotLightAngle || { value: new Float32Array(MAX_LIGHT_COUNT) };

                // 平行光的所有uniform集合
                [...this.directionalLights].forEach((light, idx) => {
                    // set方法会将源数组的所有值都会被复制到相应偏移量的目标数组中
                    lightData.directionalLightDirection.value.set(light.direction, idx * 3);      
                    lightData.directionalLightColor.value.set(light.color, idx * 3);
                });

                // 点光源的所有uniform集合
                [...this.pointLights].forEach((light, idx) => {
                    lightData.pointLightPosition.value.set(light.position, idx * 3);      
                    lightData.pointLightColor.value.set(light.color, idx * 3);
                    lightData.pointLightDecay.value.set(light.decay, idx * 3);
                });

                // 聚光灯的所有uniform集合
                [...this.spotLights].forEach((light, idx) => {
                    lightData.spotLightDirection.value.set(light.direction, idx * 3);      
                    lightData.spotLightPosition.value.set(light.position, idx * 3);      
                    lightData.spotLightColor.value.set(light.color, idx * 3);
                    lightData.spotLightDecay.value.set(light.decay, idx * 3);
                    lightData.spotLightAngle.value.set(light.angle, idx * 3);
                });

                return  { 
                            ambientLight: { value: this.ambientLight }, 
                            ...lightData, 
                        };
            }
        }

        // 材质
        class Material{
            constructor(reflection, specularFactor = 0, shininess = 50){
                // 几何体材质反射率（漫反射相关）
                this.reflection = reflection;
                // 几何体镜面反射强度（镜面反射相关）
                this.specularFactor = specularFactor;
                // 几何体镜面反射光洁度（镜面反射相关）
                this.shininess = shininess;
            }

            // 把材质属性通过uniforms访问器属性转换成着色器uniform变量
            get uniforms(){
                return  { 
                            materialReflection: { value: this.reflection }, 
                            specularFactor: { value: this.specularFactor }, 
                            shininess: { value: this.shininess }, 
                        };
            }
        }
        
        const phong = new Phong();
        // 添加一个平行光
        phong.addLight({
            direction: [-1, 0, 0],
        });
        // 添加两个点光源
        phong.addLight({
            position: [-3, 3, 0],
            color: [1, 0, 0],
        });

        phong.addLight({
            position: [3, 3, 0],
            color: [0, 0, 1],
        });

        // 分别对应4个几何体的材质
        const matrial1 = new Material(new Color('#0000ff'), 2.0);
        const matrial2 = new Material(new Color('#ff00ff'), 2.0);
        const matrial3 = new Material(new Color('#008000'), 2.0);
        const matrial4 = new Material(new Color('#ff0000'), 2.0);

        let canvas = document.querySelector("canvas");
        // 1. 创建画布宽高512的renderer对象
        const renderer = new Renderer({
            canvas,
            width:512,
            height:512,
        });

        const gl = renderer.gl;
        gl.clearColor(1, 1, 1, 1);

        (async function(){
            // 2. 创建相机（默认透视投影）
            // 视角35°
            const camera = new Camera(gl, { fov: 35 });
            // 相机的位置
            camera.position.set(0, 0, 7);
            // 相机的朝向
            camera.lookAt([0, 0, 0]);

            // 3. 创建场景
            const scene = new Transform();

            // 4. 创建几何体对象
            const sphereGeometry = new Sphere(gl);
            const cubeGeometry = new Box(gl);
            const cylinderGeometry = new Cylinder(gl);
            const torusGeometry = new Torus(gl);
                    
            // 5. 创建webgl程序
            const vertex = /* glsl */ `
                precision highp float;
                
                attribute vec3 position;
                attribute vec3 normal;
                
                uniform mat4 modelViewMatrix;
                uniform mat4 projectionMatrix;
                uniform mat3 normalMatrix;
                
                varying vec3 vNormal;
                varying vec4 vPos;
                
                void main() {
                    vPos = modelViewMatrix * vec4(position, 1.0);
                    // 计算法向量
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * vPos;
                }
            `;
            
            const fragment = /* glsl */ `
                #ifdef GL_ES
                precision mediump float;
                #endif
                #define MAX_LIGHT_COUNT 16

                uniform vec3 vCameraPos;
                uniform mat4 viewMatrix;

                // 声明 vec3 和 float 数组，数组的大小为 16。这样，对于每一种光源，我们都可以支持 16 个。
                uniform vec3 ambientLight;
                uniform vec3 directionalLightDirection[MAX_LIGHT_COUNT];
                uniform vec3 directionalLightColor[MAX_LIGHT_COUNT];
                uniform vec3 pointLightColor[MAX_LIGHT_COUNT];
                uniform vec3 pointLightPosition[MAX_LIGHT_COUNT];
                uniform vec3 pointLightDecay[MAX_LIGHT_COUNT];
                uniform vec3 spotLightColor[MAX_LIGHT_COUNT];
                uniform vec3 spotLightDirection[MAX_LIGHT_COUNT];
                uniform vec3 spotLightPosition[MAX_LIGHT_COUNT];
                uniform vec3 spotLightDecay[MAX_LIGHT_COUNT];
                uniform float spotLightAngle[MAX_LIGHT_COUNT];

                // 材质相关的属性
                uniform vec3 materialReflection;
                uniform float shininess;
                uniform float specularFactor;

                varying vec3 vNormal;
                varying vec4 vPos;

                // 镜面反射强度
                float getSpecular(vec3 dir, vec3 normal, vec3 eye){
                    // 1. 求出反射光线的方向向量
                    vec3 reflectionLight = reflect(-dir, normal);
                    // 2. 求反射光线与视线夹角的余弦
                    float eyeCos = max(dot(eye, reflectionLight), 0.0);
                    // 3.使用材质的镜面反射光洁度和材质的镜面反射强度设置镜面反射强度，指数越大，镜面越聚焦，高光的光斑范围就越小
                    return specularFactor *  pow(eyeCos, shininess);
                }

                // 获取反射模型的颜色
                vec4 phongReflection(vec3 pos, vec3 normal, vec3 eye) {
                    // 镜面反射结果
                    float specular = 0.0;  
                    // 漫反射结果
                    vec3 diffuse = vec3(0);

                    // 处理平行光
                    for(int i = 0; i < MAX_LIGHT_COUNT; i++) {
                        // 取值三维坐标
                        vec3 dir = directionalLightDirection[i];
                        // 如果平行光是0向量，跳过处理
                        if(dir.x == 0.0 && dir.y == 0.0 && dir.z == 0.0) continue;
                        // 对平行光向量按照相机位置，进行视图变换
                        vec4 d = viewMatrix * vec4(dir, 0.0);
                        // 平行光归一化处理
                        dir = normalize(-d.xyz);
                        // 平行光与每点法向量的夹角余弦值
                        float cos = max(dot(dir, normal), 0.0);
                        // 平行光照射的强度合成
                        diffuse += cos * directionalLightColor[i];
                        // 平行光对几何体的镜面反射的效果
                        specular += getSpecular(dir, normal, eye);
                    }

                    // 处理点光源
                    for(int i = 0; i < MAX_LIGHT_COUNT; i++) {
                        // 如果衰减系数都是0，跳过处理
                        vec3 decay = pointLightDecay[i];    
                        if(decay.x == 0.0 && decay.y == 0.0 && decay.z == 0.0) continue;

                        // 取值三维坐标
                        vec3 dir = (viewMatrix * vec4(pointLightPosition[i], 1.0)).xyz - pos.xyz;
                        // 光线到点坐标的距离，用来计算衰减 
                        float dis = length(dir);
                        // 点光归一化处理
                        dir = normalize(dir);
                        // 点光与每点法向量的夹角余弦值
                        float cos = max(dot(dir, normal), 0.0);
                        // 计算衰减 
                        float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));
                        // 点光照射的强度合成
                        diffuse += d * cos * pointLightColor[i];
                        // 点光对几何体的镜面反射的效果
                        specular += getSpecular(dir, normal, eye);
                    }

                    // 处理聚光灯
                    for(int i = 0; i < MAX_LIGHT_COUNT; i++) {
                        // 如果衰减系数都是0，跳过处理
                        vec3 decay = spotLightDecay[i];    
                        if(decay.x == 0.0 && decay.y == 0.0 && decay.z == 0.0) continue;

                        // 取值三维坐标
                        vec3 dir = (viewMatrix * vec4(spotLightPosition[i], 1.0)).xyz - pos.xyz;
                        // 光线到点坐标的距离，用来计算衰减 
                        float dis = length(dir);
                        // 聚光灯归一化处理
                        dir = normalize(dir);
                        // 聚光灯的朝向 
                        vec3 spotDir = (viewMatrix * vec4(spotLightDirection[i], 0.0)).xyz;
                        // 通过余弦值判断夹角范围 
                        float ang = cos(spotLightAngle[i]); 
                        // 计算聚光灯的朝向与点光源到物体表面的点坐标的方向的余弦值,比较两个夹角
                        float r = step(ang, dot(dir, normalize(-spotDir)));

                        // 聚光灯与每点法向量的夹角余弦值
                        float cos = max(dot(dir, normal), 0.0);
                        // 计算衰减 
                        float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));
                        // 聚光灯照射的强度合成
                        diffuse += r * d * cos * spotLightColor[i];
                        // 聚光灯对几何体的镜面反射的效果
                        specular += r * getSpecular(dir, normal, eye);
                    }
                    return vec4(diffuse, specular);
                }

                void main() {
                    // 根据相机位置计算对每个点的视线的向量方向
                    vec3 eyeDirection = normalize(vCameraPos - vPos.xyz);  
                    vec4 phong = phongReflection(vPos.xyz, vNormal, eyeDirection);

                    // 合成颜色
                    gl_FragColor.rgb = phong.w + (phong.xyz + ambientLight) * materialReflection;;
                    gl_FragColor.a = 1.0;
                }
            `;

            // 传入光的相关属性
            const directional = {
                vCameraPos:{ value: [0, 0, 7] },  
                ...phong.uniforms,
            };

            const program1 = new Program(gl, {
                vertex,
                fragment,
                uniforms: {
                    ...directional,
                    ...matrial1.uniforms,    
                },
            });

            const program2 = new Program(gl, {
                vertex,
                fragment,
                uniforms: {
                    ...directional,
                    ...matrial2.uniforms,    
                },
            });
            const program3 = new Program(gl, {
                vertex,
                fragment,
                uniforms: {
                    ...directional,
                    ...matrial3.uniforms,    
                },
            });
            const program4 = new Program(gl, {
                vertex,
                fragment,
                uniforms: {
                    ...directional,
                    ...matrial4.uniforms,    
                },
            });
            
            // 6. 创建网格对象
            const controls = new Orbit(camera);
            
            const torus = new Mesh(gl, {geometry: torusGeometry, program: program1});
            torus.position.set(0, 1.3, 0);
            torus.setParent(scene);

            const sphere = new Mesh(gl, {geometry: sphereGeometry, program: program2});
            sphere.position.set(1.3, 0, 0);
            sphere.setParent(scene);

            const cube = new Mesh(gl, {geometry: cubeGeometry, program: program3});
            cube.position.set(0, -1.3, 0);
            cube.setParent(scene);

            const cylinder = new Mesh(gl, {geometry: cylinderGeometry, program: program4});
            cylinder.position.set(-1.3, 0, 0);
            cylinder.setParent(scene);
            
            // 7. 渲染
            requestAnimationFrame(update);
            function update() {
                requestAnimationFrame(update);
                controls.update();
                renderer.render({scene, camera});
            }

        })()
    </script>
</body>
</html>